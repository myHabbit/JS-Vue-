# JS篇

### 1.DOM和BOM是什么

总的来说，DOM 是用来操作文档内容的，而 BOM 是用来操作浏览器窗口和页面的其他部分，例如浏览器的工具栏、地址栏、状态栏等。通常情况下，我们常常使用 DOM 中的方法来操作页面元素，例如查询、添加、修改等操作，而使用 BOM 中的方法来控制浏览器行为，例如跳转页面、弹出对话框等操作。

### 2.什么是回调函数

如果将函数A做为参数传递给函数B时 我们称函数为**回调函数**

**当一个函数做为参数传递给另外一个函数的时候 这个函数就是回调函数**

### 3.事件委托

事件委托实际就是用了事件冒泡 当一个元素需要绑定事件的时候 可以将这个时间加到他的父元素身上

是利用事件流的特征解决了一些开发需求的知识技巧

 **优点：减少注册次数 可以提高程序性能**

 **原理：事件委托其实是利用事件冒泡的特点**

给**父元素**注册事件 当我们触发子元素的时候 会冒泡到父元素身上 从而触发父元素的事件

**实现：事件对象.target.tagName 可以获得真正触发事件的元素**

### 4.map方法

Map方法可以遍历数组**处理数据** 并且**返回新的数组**

Map也称为映射，映射是个术语，指两个元素的集之间元素相互“对应”的关系。

Map重点在于有返回值。forEach没有返回值

### 5.join方法

将数组里的内容转换为一个字符串

### 6.js的执行机制

JS语言最大的特点就是单线程 **同一时间只能做一件事**

**单线程就意味着 所有任务需要排队 前一个任务结束 才会执行后一个任务 这样所导致的问题是 如果JS执行的时间过长 这样就会造成页面的渲染不连贯 导致页面渲染加载阻塞的感觉**

### **执行机制**：

1. 1. 1. 1. **先执行执行栈中的同步任务**
         2. **异步任务放入任务队列中**
         3. **一旦执行栈中的所有同步任务执行完毕 系统就会按次序读取任务队列中的异步任务 于是被读取的异步任务结束等待状态 进入执行栈 开始执行**

**由于主线程不断的重复获取任务，执行任务，再获取任务，再执行 所以这种机制叫做事件循环（event  loop）**

```js
在JavaScript中，任务被分为宏任务（macro task）和微任务（micro task），用于处理不同的异步操作。

宏任务（macro task）包括但不限于以下操作：

setTimeout 和 setInterval 定时器
I/O 操作（如读写文件）
页面渲染
用户交互事件（例如点击事件）
浏览器的事件回调
宏任务代表着一些较大的、离散的工作单元，它们会进入事件队列，按照顺序一个接一个地执行。

微任务（micro task）是一个较小的任务单元，在当前任务执行完毕后立即执行，不会进入事件队列。常见的微任务包括：

Promise 的回调函数
MutationObserver 的回调函数
process.nextTick（仅适用于Node.js）

在事件循环中，微任务具有比宏任务更高的优先级。

当执行栈为空时，事件循环会检查是否存在微任务队列。如果有微任务，则会立即执行微任务队列中的所有任务，直到微任务队列为空，然后再执行下一个宏任务。
```



### 7.执行上下文

执行上下文简单来说 就是js代码的执行环境 分为全局执行上下文  函数执行上下文和块级执行上下文呢

全局执行上下文：在全局环境下 任何函数都可以被调用  可以访问所有的全局变量

函数执行上下文：在函数内部的 执行环境 只有函数内部的变量和对象可以访问 函数外部不可以访问

块级执行上下文：在函数内部声明的函数和变量 作用域仅限于该函数内部  块级上下文可以用{}定义

### 8.作用域和作用域链

作用域分为 全局作用域 和局部作用域  局部作用域可以分为 函数作用域和块级作用域

全局作用域 就是在全局声明的对象变量 等 在代码任何地方都可以访问

函数作用域 就是在函数内部声明的变量 只能在函数内部访问 外部访问不到

块级作用域 在js中被{}包裹的就是代码块 在块级作用域中声明的变量只能在当前代码块内部访问，超出该代码块则不可访问。

作用链 说白了就是一种变量查找机制 在代码执行的时候 首先会在当前作用域去查找需要的变量 如果没有 则会依次逐级向外查找 直到全局作用域

### 9.闭包

闭包就是函数内部可以访问到函数外部的变量

闭包的主要作用：1.实现数据私有  2.延长变量的生命周期 

闭包的实际应用: 防抖和节流，模块化开发

但是得慎重使用: 可能会造成内存泄漏

内存泄漏就是  分配出来的内存 因为程序的某种原因 未被回收或者是无法释放就叫做内存泄漏

### 10.垃圾回收机制

垃圾回收机制就是   内存在不使用的时候会被垃圾回收回收掉

引用计数法：跟踪并记录变量 如果被引用就+1  减少一次引用就-1  如果引用次数为0  则会被垃圾回收回收掉

标记清除法： 从根部出发扫描内存中的对象  能查找到的就是需要用的 查找不到的就是不用的 就会被标记 然后被垃圾回收回收掉

### 11.创建新对象的顺序

1.创建一个空的对象

2.将这个新对象的_proto_属性 指向构造函数的prototype属性

3.改变this指向 将this指向指向 新对象，

4.执行里面的代码

5.返回新对象

### 12.var let const区别

1.var有变量提升  let const 没有  所谓变量提升就是 在js代码执行的时候  会把var声明的变量 提到当前作用域的最前端 然后只提升变量声明 不提升变量赋值

2. let const声明的变量 会生成块级作用域
3. var可以重复声明 let  const 不可以
4. Let 声明的是变量 可修改   const 声明的是常量不可修改

### 13.原型和原型链

在 JavaScript 中，每个对象（除了 null 和 undefined）都有一个原型（prototype）。原型是一个对象，它包含共享的属性和方法，可以被其他对象继承使用。

通过构造函数new实例化出来的新对象 身上会有个隐式原型(_proto_属性) 就指向了构造函数的显示原型（prototype属性），然后函数也是对象 所以构造函数的原型上的隐式原型指向了object.prototype  构造函数的隐式原型指向了function.prototype 然后它的隐式原型最终也指向了object.prototype  然后原型链的顶端是null

当我们访问一个对象的属性时，JavaScript 引擎会首先查找该对象本身是否具有此属性，如果没有，则会到其原型对象中查找，如果原型对象中也没有，则会继续向上查找，直到找到最顶层的原型对象（通常是 `Object.prototype`）或者找到该属性为止。

### 14.原型链的作用

原型链的作用是实现对象之间的继承和属性共享。

JavaScript 中的继承是通过原型链来实现的。当我们创建一个对象时，如果该对象本身没有某个属性或方法，那么 JavaScript 引擎就会沿着该对象的原型链向上查找，直到找到该属性或方法为止。这样，我们可以在不重复定义代码的前提下，实现从一个对象派生出另一个对象，并在派生的对象中添加新的属性和方法。

### 15.this

1.普通函数：

 单独使用 this指向全局对象

函数中使用 this指向函数的调用者

对象的方法中使用 this指向这个对象

### call,apply,bind的基本介绍

call  apply  bind 方法可以修改this指向

调用call/apply/bind 的必须是个函数

```js
语法：
fun.call(thisArg, param1, param2, ...)
fun.apply(thisArg, [param1,param2,...])
fun.bind(thisArg, param1, param2, ...)
```

它们三个区别在于

call 和 apply 方法大差不差 唯一不同点  apply方法 第二个参数 是以数组形式传递的 call方法不是   第一个参数都是this的指向对象

bind方法： **会让一个函数总是显示的绑定到一个对象上**

​		 使用bind方法，bind() 方法**创建一个新的绑定函数**（bound function，BF）；

​		 绑定函数是一个 exotic function object（怪异函数对象，ECMAScript 2015 中的术语）

​		 在 bind() 被调用时，这个**新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。**

​		 后续再调用传参，不会改写，只会往后传参

#### **call apply和bind的区别**

 call/apply改变了函数的this上下文后马上**执行该函数**

 bind则是返回改变了上下文后的函数,**不执行该函数**

### 16.js的八个数据类型

string  number  boolean null underfind object bigint symbol

### 17.primose

#### 1.primose概念

ES6新增的引用类型 可以通过new操作符来实例化

通俗地讲，Promise 就像一个容器，里面存放着未来才会结束，返回结果的容器，返回的结果只需要在出口处接收就好了。从语法上讲，Promise 是一个对象，从它可以获取异步操作的消息。

####  主要的应用场景：

ajax  axios 请求  通俗来说，由于网速的不同，可能你得到返回值的时间也是不同的，但是我“下一步要执行的代码依赖于上一次请求返回值，这个时候我们就需要等待，结果出来了之后才知道怎么样继续下去。

#### 好处

就是 防止回调地狱

#### promise三种状态

pedding  表示等待中 还没有结果

Fulfilled  已经完成 表示得到了我们想要结果 可以继续往下执行

rejected  也表示完成 但是结果不是我们想要的  拒绝执行

#### then方法的使用

then方法返回的是一个promise对象 对象的状态由回调函数的执行结果所决定

如果回调函数中返回的结果是 非promise对象 状态未成功 则表示成功 返回值为promise对象的成功值

如果返回的是promise的属性 返回的promise的状态为成功 那么返回的promise对象的状态也是成功的 反之则失败

抛出错误 也是个失败的promise状态  错误值就是抛出的值

### async和await函数

async 函数 ：

如何都可以被声明为一个async函数 因为更好的实现异步功能  返回值是一个promise

函数内部可以添加任意的一个语句来执行 但是其真正的目的是为了得到一个promise对象的状态以及结果值

#### await

1.async 函数 结合await 表达式

  1.1 async函数当中 不一定完全结合await

 1.2 有await函数的一定是async函数

2.await相当于是then 直接可以拿到实例化promise对象的结果值

3.await一定要写在async函数中 但是async函数之中可以没有await

#### Promise方法

#####  all方法

```javascript
Promise.all 方法，提供了并行执行异步操作的能力，并且在所有异步操作完成之后，统一返回所有结果。
使用如下：
	 Promise.all([
  	new Promise(resolve=>resolve('a')),
	 new Promise(resolve=>resolve('b')),
	]).then(res=>{
	 console.log('all',res)//【'a' , 'b'】
	 })
!!! all 接收到的是一个数组，数组长度取决于 Promise 的个数。

```

##### race方法

```javascript
Promise.race 用法与 all 一样，只是返回结果上不同，它返回的是执行最快的那个 Promise 的结果。
 用法： 
    Promise.race([
	 new Promise(resolve=>
  	 setTimeout(()=>{
   	 resolve('a')
  	 },100)
	  	),
 	new Promise(resolve=>
 	 setTimeout(()=>{
  	 resolve('a')
 	  },200)
 	 ),
	 ]).then(res=>{
 	 console.log('race',res) // 返回 a
	})


```



### 18 防抖和节流

防抖就是 单位时间内 用户频繁触发事件 只执行最后一次

思路：

1.创建一个空的存放定时器的变量

2.判断是否已经开启定时器 如果开启则清空定时器

3.如果没有定时器 则开启一个定时器 并存在变量里

4.定时器中调用执行的函数



节流 就是单位时间内 不管用户触发多少次执行 只执行一次

思路：

1.创建一个空的存放定时器变量

2.判断是否已经有定时器 如果有 则不开启新的定时器了

3.如果没有则开启一个定时器 存放在变量里面

4.定时器里面调用函数

5.定时器里面要清空定时器





# Vue2篇



## Vue2实现双向绑定原理

```js
我们已经知道如何实现数据的双向绑定了，那么首先要对数据进行劫持监听，所以我们首先要设置一个监听器Observer，用来监听所有的属性，当属性变化时，就需要通知订阅者Watcher，看是否需要更新。因为属性可能是多个，所以会有多个订阅者，故我们需要一个消息订阅器Dep来专门收集这些订阅者，并在监听器Observer和订阅者Watcher之间进行统一的管理。因为在节点元素上可能存在一些指令，所以我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令初始化成一个订阅者Watcher，并替换模板数据并绑定相应的函数，这时候当订阅者Watcher接受到相应属性的变化，就会执行相对应的更新函数，从而更新视图。
整理上面的思路，我们需要实现几个步骤，来完成双向绑定：

Observer 监听器，用来劫持并监听所有属性，如果有变动的，就通知订阅者。
Compile 解析器，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器 将模板中的变量替换为数据
Dep 存储依赖和派发更新，监听器和订阅者的桥梁。
Watcher 订阅者，可以收到属性的变化通知并执行相应的函数，从而更新视图。
```

## vue组件中的name属性

```js
1.用keep-alive 缓存组件的时候可以用到
2.DOM做递归组件时候需要调用自身name
3.当你用 vue-tools 时，vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的。
```



## Vue中的指令

```javascript
v-model :双向绑定
v-for   : 循环
v-if 和 v-else-if  v-else :判断
v-show :显示隐藏
        true:block
        flase: style='display:none'
v-if 和 v-show 区别：
  1.v-if是创建和删除dom元素，v-show是控制元素显示和隐藏
  2.使用场景：
      1.追求首次加载速度 ==> v-if
      2. 业务是频繁切换 ==>  v-show
```



### Vue中的修饰符有哪些

```js
1.事件修饰符
     .stop      阻止冒泡
	.prevent	阻止默认行为
	.once		事件只会触发一次
	.passive	立即触发默认行为
	.self       只有在event.target是当前元素时触发
	.native		把当前元素作为原生标签看待
2.按键修饰
     .keyup      键盘抬起
      .keydown    键盘按下
3.系统修饰符
	.ctrl
	.alt
	.meta
4.鼠标修饰符
     .right       鼠标左键
	 .left        鼠标右键
	 .middle      鼠标中键
5.表单修饰符
     .lazy         输入完之后在显示
      .trim        去除空格
      .number      输入是数字或转为数字
```



## 关于生命周期

vue2中 生命周期有八个

beforeCreate Created  （创建前后）

 beforeMount   Mounted   （挂载后）

beforeApdate  Apdated      （更新数据前后）

 beforeDestory  destoryed  （销毁前后）

#### 一旦进入组件会执行那些生命周期

默认执行 前四个生命周期：

  beforeCreate  Created  （创建前后 没有DOM）

  beforeMount （挂载前，正在准备DOM）   Mounted （挂载后，DOM结构有了）

#### 在组件引入子组件，那么生命周期执行的顺序是？

1. 先准备父组件的数据 就是执行生命周期的 前三个 beforeCreate  Created  beforeMount  此时dom结构还未挂载
2. 然后执行子组件中的 前四个生命周期  beforeCreate  Created  beforeMount   Mounted  
3. 最后 执行父组件的 Mounted 

#### 为什么发送请求不在beforeCreate里面? beforeCreate 和 created 有啥区别

#####      为什么发送请求不在beforeCreate里面? 

因为如果这个请求是在methods里面封装好的，在beforeCreate 调用的时候  beforeCreate阶段是拿不到methods里面的方法的 （会报错 找不到这个方法）

##### 	 beforeCreate 和 created 有啥区别？

   beforeCreate阶段没有$data(data中的数据)

   created中有$data

   beforeCreate阶段拿不到methods的方法

   created可以拿到methods里面的方法

##### 在created中如何获取DOM

1.只要写异步代码，获取dom是在异步中获取的就可以了

​	例如settimeout 、请求、promise.xxx() 等等...

2.使用vue内置的 this.$nextTick

#### 发送请求是在created还是在mounted？

 这个问题具体要看项目和业务的情况，因为组件的加载顺序 父组件引入了子组件 先执行父组件的前三个生命周期，在执行子组件的前四个生命周期 如果我们的业务是父组件引入子组件 并且优先加载子组件的数据 那么在父组件中 当前的请求要放在mounted里面 如果当前组件没有依赖关系，那么放在那个生命周期请求都是可以的

#### 如果加入keep-alive会执行那些生命周期？

#####    keep-alive概念：

  在 Vue 中，`<keep-alive>` 是一个抽象组件，用于在切换组件时缓存不活动的组件实例，从而提高应用程序的性       能。 **说直白点 就是用来缓存当前组件**

![image-20230617113028857](C:\Users\G1330\AppData\Roaming\Typora\typora-user-images\image-20230617113028857.png)

##### 加入keep-alive 新增的两个生命周期

```javascript
 如果使用了keep-alive这个组件 当前的组件会额外增加两个生命周期（原先的8个 在加两个）

**activated  (进入到这个组件 )**

**deactivated （离开这个组件）**

如果当前组件加入了keep-alive，第一次进入组件的时候 会执行五个生命周期

beforecreate  created beforemount  mounted activated

如果当前组件加入了keep-alive，第二次或者第n次 只会执行一个生命周期 activated

如果没有加入 第二次和第n次 beforecreate  created beforemount  mounted
```

#### 你在什么情况下用过生命周期？说一说生命周期的使用场景

```javascript
created      =》单组件请求

mounted      =》同步可以获取dom  如果子组件先请求 父组件后请求

destoryed    =》关闭页面 记录视屏播放的时间，初始化的时候 从上一次的历史开始播放

activated    =》 判断id是否相同 如果不相同发起请求
```







## 组件间的通信

#### 组件之间通信（传值）的方式

##### 父组件传后代（后代拿到了父组件数据）

**1.props**  

```javascript
父组件 引入子组件   v-bind绑定数据
	<List v-bind:str= 'str'></List>
子组件通过props来接收
		propse:{
            type:String,   //传递的类型
            default:''     //默认值
        }
！！这种方式 父传子很方便 但是父组件传给孙子辈的就很麻烦 需要父传子  子在传给孙
！！！！ 这种方式  子组件不可以直接修改父组件的数据
```

**2.子组件直接使用父组件的数据** （不属于传值了，在这里父组件没有传递数据）

```javascript
子组件可以用 this.$parent.数据  去拿到父组件的数据 
孙组件如果想拿到数据 可以用 this.$parent.$parent.数据   但是不建议这样使用
！！！子组件可以直接修改父组件的数据
```

 **子组件如何直接修改父组件的值呢？**

```javascript
子组件中使用  this.$parent.数据  去修改父组件的值
```

##### provide/inject  （父子 父孙传递）

```javascript
provide/inject   ==》依赖注入
！！优势：父组件可以直接向某个后代组件传值（不让一级一级的传递）
```

##### 后代传父组件 （父组件拿到了后代数据）

**1.自定义事件  $emit**

```javascript
 子组件定义自定义事件  this.$emit
	this.$emit('change',123)
 父组件 绑定自定义事件拿到值
 	<List v-on:change='changebtn'></List>
	changebtn(val){
        console.log(val)  此处的val就是子组件传过来的数据123
    }
```

**父组件直接使用子组件数据**

```javascript
1. this.$children[子组件下标].数据 
2. <List ref:'child'></List>
   this.$refs.child.数据
```

**父组件如何直接修改子组件的值**

```javascript
 <List ref:'child'></List>
  this.$refs.child.数据= '新数据'
```

**如何找到父组件**

```javascript
this.$parent  拿到父组件
```

##### 平辈之间的传递（兄弟可以拿到数据）

 **1.全局事件总线**

```javascript
全局事件总线  适用于任意组件间通信

  1. 首先在main.js里面安装全局事件总线
      new Vue({
          ....
          beforeCreate(){
          Vue.prototype.$bus = this
      }
      })
  2.使用全局事件总线
  	 1.接收数据
     简单来说就是，谁要接收数据，自定义事件就绑定在谁身上
     mounted(){
 		 // 绑定自定义事件
 		 this.$bus.$on('自定义事件名', (接收参数)=>{
   		 console.log('我是TestB组件，收到了数据', 接收参数);
  		})
	}
    2.发送数据
    简单来说，谁是数据的发送者，谁就来触发事件
    methods:{
  		// 触发事件,事件名不能重复
  		触发事件方法名(){
    	this.$bus.$emit('自定义事件名', 传递参数);
  		}
	 },
         
         
   ！！！！最好在beforeDestory钩子函数中销毁事件
      // 销毁对应自定义事件
        beforeDestroy(){
          this.$bus.$off('lufei')
        }
    }
     
```

**2.消息订阅与发布**

```javascript
消息订阅与发布
	1.安装: npm install -i pubsub-js
	2.引入: import PubSub from 'pubsub-js' 
	收到数据的一方订阅消息 pubsub.subscribe('hello',function (){})
	
	发送数据的一方发布消息 pubsub.publish('hello',数据)
	
	取消消息的订阅        PubSub.unsubscribe(token)
	
!!!!注意
	订阅的回调函数可以写成箭头函数，也可以传递组件mothods的函数，建议不要用其它写法。（其它的函数使用		this时this不是组件实例对象）
	
	订阅消息的销毁：订阅消息后会返回一个订阅ID，将ID可以保存到组件data中，销毁时通过ID进行销毁。
	
	接收数据时，注意函数第一个参数是订阅的名字，第二个参数才是发送过来的数据。
```

##### 如何找到根组件

```javascript
this.$root
```

##### keep-alive

```javascript
keep-alive是什么： 缓存当前组件
```

##### slot/插槽

```javascript
匿名插槽: 插槽没有名字
```

```javascript
具名插槽: 插槽有名字
```

```javascript
作用域插槽: 传值
```



## 如何封装组件

```javascript
 组件一定要有难点 ，涉及到的知识点：slot 、组件通信...
```



## 关于Vuex

```javascript
vuex： 状态管理  可以帮助我们管理共享状态
状态：登录状态等

  优点：
   方便操作
   方便管理
   方便传值
```



### Vuex有哪些属性

```javascript
state     ==> 定义全局共享的属性
```

```javascript
getters   ==>  针对于state里的数据进行二次计算  相当于computed计算属性
```

```javascript
mutations ==> 存放同步方法的		
```

```javascript
actions   ==> 存放异步方法的，并且是来提交mutations的
```

```javascript
modules   ==> 把vuex再次进行模块之间的划分
```

### Vuex使用state值

```javascript
this.$store.state.定义的数据
```

```javascript
辅助函数: ...mapState 
1.引入   import {mapState} from 'Vuex'
2.使用
   computed:{
       ...mapState(['数据'])   //这里的数据就是state里面定义的数据
   }
```

#### 以上两种方法都可以拿到state的值，那么区别是什么？

```javascript
使用this.$store.state.xxx可以直接修改vuex的state的数据
!!! this.$store.state.xxx  是直接使用的是store仓库的数据  所以可以直接修改
```

```javascript
...mapState不可以直接修改vuex的state的数据
!!!  ..mapStore 相当于复制了一份store仓库里的数据给你用 所以无法直接修改vuex中的数据
```

### Vuex的getters值修改

##### 使用getters的两种方法：

```javascript
this.$store.getters.xxx
```

```javascript
辅助函数: ...mapGetters
1.引入   import {mapGetters} from 'Vuex'
2.使用
   computed:{
       ...mapGetters(['数据'])   //这里的数据就是getters里面定义的方法对数据进行计算完的返回值
   }
```

#### getters里面的数据无法被修改

```javascript
!!!! 切记 无法修改
```

### Vuex的mutations和actions区别

```javascript
相同点：
 mutations 和 actions 都是来存放全局方法的，这个全局方法return的值拿不到
```

```javascript
不同点:
 mutations ==> 同步返回
 actions   ==> 返回值为promise对象，可以执行相关异步操作

 mutations的作用是来修改state的值,actions的作用是来提交mutations的
```

### Vuex中的modules

```javascript
modules  进行模块之间的划分
1.在外部划分出去一个user模块 
2.如果想要用到user里面的数据
必须在modules里面进行挂载   
modules:{
    user
}
3.组件中的使用:
this.$store.state.user.xxx     //这里会指定 拿的是user模块下的state里面的数据
辅助函数: ...mapState
1.引入   import {mapState} from 'Vuex'
2.使用
   computed:{
       ...mapState({
           token:state=>state.user.token
       })   
   }
```

### Vuex持久化存储

**面试题：  在页面使用了state的值：1，然后把1修改成了2，然后刷新了页面 又回到了1为什么**

```javascript
Vuex本身不是持久化存储的数据，vuex是个状态管理仓库 {state:全局属性} ==> 就是存放全局属性的地方
```

```javascript
实现持久化存储：
1.自己写 localStorage
2.使用   vue-persistedstate插件
```

```javascript
插件使用方式：
 1.引入插件
 import createPersistedState from 'vue-persistedstate '

 2.在store配置
 /* vuex数据持久化配置 */
 plugins: [
  createPersistedState({
   // 存储方式: LocalStorage、sessionStorage、cookiesstorage:
   window.sessionStorage,// 存储的 key 的key值
   key:"store"render(state)
   //要存储的数据: 本项目采用es6扩展运算符的方式存储了state中所有的数据
   return { ...state };
 }
})
```



## 关于路由

### 路由的模式和区别

```javascript
路由的模式：history , hash
```

```javascript
区别(表面)：
1.从表象来看  hash模式的URL中的路径部分会有#   history模式的URL中的路径部分中没有#（更加美观）
```

```javascript
区别(深度):
1.关于找不到当前页面  发送请求的问题
   history模式会给后端发送一次请求，而hash模式不会
2.关于项目打包前端自测问题
   hash模式可以看到项目内容
   但是history默认情况下看不到内容（需要配置额外项）
```

### 实现路由之间切换出现高亮效果

```javascript
<router-link  active-class='active'  to:'/about'>About</router-link>
!!! 此处的 active-class 可以配置高亮样式
```

### 子路由和动态路由

```javascript
子级路由：
   通过children配置子级路由
   		routes :[
            {
                path:' /about
                component:About ,
            }
			{
            	path:' /home',
           	 	component :Home
            	children:[                 //通过children配置子级路由
           			 {
            			path:'news'，       //此处一定不要写: /news
            			component:News
           			 } 
  跳转的时候要写完整路径
  	<router-link to="/home/news">News</router-link>
```

### 路由传值			

```javascript
路由传值分为两种：
 1.query
   传值方式1:
          <router-link :to="{ path: '/home', query: { username: username } }">
   对象写法：
		 跳转并携带query参数，to的对象写法
           <router-link:to="{
					path:'/home/message/detail'
					query:{id:666,
                        title:'你好'
                     }
				}
   传值方式2：
		跳转并携带query参数，to的字符串写法
 		<router-link :to="/home/message/detail?id=666&title=你好”跳转</router-link>

 获取到query参数的值
        this.$route.query.username
 
 2.params
   传值方式1：
         跳转并携带params参数，to的字符串写法
		 <router-link :to="/home/message/detail/666/你好”跳转</router-link>
   对象写法：
    	 跳转并携带params参数，to的对象写法
       		<router-link
				:to="{
					name:'xiangqing',
                    params :{
						id:666,
						title:'你好
                    }
				}
    传值方式2：
        <router-link :to="{ name: 'home', params: { username: username } }">
   获取params参数数据
		this.$route.params.username

 !!!注意点1
   	params 传参后，刷新页面会失去拿到的参数。所以路由参数要修改为 '/login/:username'（官方称为动态路由）
    
   例如：
   		const routes = [
  		{
   		 path: '/login',
    		component: Login
  			},
 		 {
   		 path: '/home/:username',
   		 name: '/home',
   		 component: Home
 		 }
            
 !!!注意点2
    路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置!
```

### 导航故障

```javascript
导航故障：在重复进入相同路由时（不论是通过路径，还是路由名称进入），会提示不允许导航到当前位置，就会报错，这样就出现了导航故障
```

解决导航故障：

```javascript
方法一：
为跳转错误的方法全局加上错误捕获。

import VueRouter from 'vue-router'
const routerPush = VueRouter.prototype.push,
VueRouter.prototype.push = function (location){
    return routerPush.call(this, location).catch(error => error)
}
```

```javascript
方法二：
直接在路由跳转报错的那个地方加上.catch(error => error)

export default {
  data() {
    return {
      routeName: ''
    }
  },
  methods: {
    gotoHandle() {
      this.$router.push({name: this.routeName}).catch(error => error)
    }
  }
}
```

### $route 和 $router 区别

```javascript
$router  不仅包含当前路由，还包含整个路由的属性和方法，它是“路由实例”对象包括了路由的跳转方法，钩子函数等
也可以说router是个 路由管理器

$route  包含当前路由对象，是一个局部的对象，可以获取对应的name，path，params，query等
```

### 导航守卫

```javascript
1.全局守卫

  beforeEach 路由进入之前
  afterEach  路由进入之后
  
2.路由独享守卫

  beforeEnter  路由进入之前
  
3.组件内守卫

  beforeRouteEnter  路由进入之前
  brforeRouteUpdate 路由更新之前
  beforeRouteLeave  路由离开之前
```



## 关于API

### $set

```javascript
面试题：你有没有碰到过 数据更新，视图没有更新的问题    -->$set
this.$set(this.arr,'1','xxxx')  第一个参数为目标对象，第二个参数为想要修改的内容(数组就是下标) 第三的参数为修改后的数据
```

### nextTick

```javascript
$nextTick  是一个异步的，返回的参数是个函数
使用：
this.$nextTick() 功能：nextTick指定的回调函数会在DOM节点更新完毕之后再执行
源码|原理:
$nextTick( callback ){
return Promise.resolve().then(()=>{
    callback();
 })
}
面试题： 如果要在生命周期钩子created获取DOM该如何获取
本身同步的是获取不到的  
1. 但是可以写一个异步任务就可以获取（比如定时器）
2.使用vue自带API nextTick获取  原理就是返回了个promise.then  让整个的callback异步去执行
```

### $refs

```javascript
用来获取dom
```

### $el

```javascript
$el 获取当前组件的根节点
```

### $data

```
$data 是用来获取当前组件的data数据的
```

### $children

```javascript
$children 是获取到当前组件的所有子组件的 返回的是数组格式的
```

#### $parent

```javascript
找到当前组件的父组件 如果找不到返回自身
```

#### $root

```javascript
找到根组件
```

### data定义的数据

```javascript
面试题：在data中定义数据，定义的数据在return内 和return外 有啥区别

 1.return外 单纯修改这个数据是不可以修改的  因为没有被get/set
 2.return内 是可以被修改的
```

### cpmputed计算属性

```javascript
computed 两种写法:
1.  computed:{
     changeStr(){
         return this.str
     }
 }
 2. computed:{
     get(){
         	return this.str
     },
      set(){
          
      }
 }

面试题1：computed计算属性的结果值，可以修改吗？
是可以修改的   但是需要通过完整写法 get/set写法才可以

面试题1： 如果当前组件中的v-model绑定的是compted的值，那么可以修改吗？
是可以修改的 但是需要通过完整写法 get/set写法才可以
```

### watch

```javascript
watch两种写法：
 1. watch:{
     str(newvalue,oldvalue){
         console.log(newvalue,oldvalue)
     }
 }

 2. watch:{
     str:{
         handler(newvalue,oldvalue){
             console.log(newvalue,oldvalue)
         },
             immediate:true,      //初始化的时候执行一次
             deep:true            //深度监听
     }
 }
```

### methods 和 computed区别

```javascript
computed是有缓存机制的（如果值没有变化 但是调用了四次 一旦值发生改变 虽然调用了四次 但是只会执行一次 剩下的三次会走第一次缓存后的结果）  methods是没有缓存机制的（调用几次执行几次）
computed不支持一步任务 但是watch支持异步
computed必须有返回值 但是watch没有
例如：购物车单价总价这些 都会用computed 不会用到methods
```

### _mixin混入（混合）

```javascript
 概念：混合就是复用配置
```





## 关于指令

### 如何自定义指令

```javascript
全局: main.js直接写的
Vue.directive('demo'，{
    inserted: function (a,b,c) {
    console.log( a,b,c );
	}
})
```

```javascript
局部: 某一个组件内
<script>
export default {directives: {
demo: {
  bind: function (el) {
   console.log( 1 )
  }
}
}
</script>
```

### vue单项绑定

```javascript
双向绑定：v-model  input框就是要用到双向绑定，获取到用户输入的值
```

```javascript
单项绑定：v-bind   父子之间的通信就是单项绑定 子不能直接修改父的数据
```



### v-if和v-for优先级

```javascript
在vue2中：v-for优先级 大于 v-if 
```

```javascript
在vue3中： v-if优先级 大于 v-for
```

## 关于原理

### $nextTick原理

```javascript
功能： 获取更新后的dom
```

```javascript
$nextTick( callback ){
return Promise.resolve().then(()=>(
    callback();
    })
}
nextTick返回一个promise，他是一个异步行为 原理就是让callback 在promise.resolve.then这个异步行为里面去执行
```



## axios

#### 要使用axios 下载和引入

```javascript
下载：
npm install axios -S
引入:
import axios from 'axios'
```

#### 使用axios

```javascript
axios.get('xxxxx') 返回的是一个promise
想要拿到数据 就要用到then方法 axios.get('xxxxx').then(res=>{ })

或者使用 async 和await
async created(){
    let res = await axios.get('xxxxx?id=1')
    console.log(res)
}
```

```javascript
请求方式： axios.get()  axios.post()  axios({})
```

```javascript
get请求
axios.get('http://xxxx')
传递参数：
axios.get('http://xxxx?act=1&page2')
  此处给后端传递的参数的就是  act:1,page:2
```

```javascript
post请求
axios.post('http://xxxxxx',{
    act:1,
    page:2
})
```

```javascript
axios({})写法

axios({
    url:'xxxx',         //请求路径
    method:'get/post',  //请求方式 默认为get
    params:{}           // get请求方式给后端传递的参数
    data:{}             //post请求给后端传递的参数
    headers: {}         //自定义请求头
	timeout:            //请求超时时间
	responseType:json   // 响应的数据类型 默认json
  })
```

#### 网络请求 ==> 在公司里面怎么做

##### 前端请求接口会出现的情况

```javascript
1.一切正常 不会出现跨域问题 或者后端解决跨域了
2. 会出现跨域的问题？该怎么解决？
跨域： 浏览器当前打开的页面所在的域与请求资源所在的域不同 （同源策略）协议名 主机名 端口号 必须一致 否则就是跨域了
注意：请求发了 服务器收到了也返回数据了 但是浏览器没提供给我们开发者

!!!!  出现跨域的报错 (has been blocked by CORS policy:No Access-Control-Allow-Origin header is present on the requested resource.) 

解决：
  1.前端解决
	2. jsonp   实则用的是script 里面的src属性 但是只能解决get请求跨域问题
	2. 设置代理（Vue中解决跨域问题的方式）
     
  2.后端解决
  	1.cors：后端配置服务器方法
```

##### 在vue项目中如何设置代理：

```javascript
如果你的前端应用和后端 API 服务器没有运行在同一个主机上，你需要在"开发环境下"将 API 请求代理到 API 服务器。
具体配置  打开vue.config.js
    devServer: {
         proxy: 'http://localhost:4000'
  }
//配置完成之后 重启一下项目

!!注意： 代理在开发环境生效 ，生产环境不生效

解决代理打包后路径不对的问题： [设置环境变量]
开发环境(.env.development) 生产环境（.env.production）

```

##### 在公司里面如何做（前端请求接口封装的操作）

```javascript
axios二次封装：对url统一管理 方便日后更换
 二次封装操作：
 
 //在src/utils/request.js文件
 
//引入axios
import axios from 'axios '

//创建axios对象
 const request = axios.create({
     baseUrl:'',   所有请求的公共路径
     timeout:5000
 })
 //请求拦截器  前端给后端的东西
 request.interceptors.request.use(config=>{
     //发送请求之前：   ==> 判断用户是否是登陆状态
     return config
 },error=>{
     return promise.reject(error)
 })

//响应拦截器   后端给前端的东西
request.interceptors.reponse.use(response=>{
    return response
},error=>{
    return promise.reject(error)
})

//返回axios对象
export default request
```

#### API的解耦

```javascript
封装的意义（为什么要封装）： 
1.单独维护api的请求，会让项目中的所有的请求方便管理
2. 很多页面用用一个请求，无需写很多次，直接调用封装好的函数就可以了

语法：
import request from '@/utils/request.js'

export const getSubject = function(){
    return request({
        url:'xxx',
        method:'get',      //默认get
        params:'xxx'       //传递参数 get为params  post为data
    })
}
```



##### 在公司里面如何做（项目上线如果出现请求问题如何处理）

```javascript
设置环境变量：项目的根目录创建文件
  开发环境：.env.development
  生产环境：.env.production

变量名是：VUE_APP开头
 
用法：
VUEAPP_TITLE = 小鹿线开发环境
VUE_APP_BASE_API = ‘https://fawn.xuexiluxian.cn/api’

VUEAPP_TITLE = 小鹿线生产环境
VUE_APP_BASE_API = ‘https://fawn.xuexiluxian.cn/api’

```

##### 前后端联调：

```javascript
   在公司做项目，你（前端）如何和后端联调
   总结：出现错误 ==> 调试错误==> 前端和后端 "沟通"
   当然：数据结构不合理也可能会联调
```







# Vue3部分

## Vue2和vue3版本的实现响应式的区别

vue2是用object.defindProperty() 对属性的读取、修改进行拦截（数据劫持） 通过getter 和setter来监听数据，当对象的属性被访问或修改时，getter 和 setter 函数会被触发，从而实现了对数据的监听和更新。

vue3是通过es6的proxy代理来实现 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等

### 选项式Api与组合式Api

- 选项式Api

```js
js复制代码<template>
<div @click="changeMsg">{{msg}}</div>
</template>
<script>
export default  {
  data(){
    return {
     msg:'hello world'
    }
  },
  methods:{
    changeMsg(){
      this.msg = 'hello juejin'
    }
  }
}
</script>
```

- 组合式Api

```js
js复制代码<template>
 <div @click="changeMsg">{{msg}}</div>
</template>

<script>
import { ref,defineComponent } from "vue";
export default defineComponent({
setup() {
    const msg = ref('hello world')
    const changeMsg = ()=>{
      msg.value = 'hello juejin'
    }
return {
  msg,
  changeMsg
};
},
});
</script>
```

- setup 语法糖

```js
js复制代码<template>
  <div @click="changeMsg">{{ msg }}</div>
</template>

<script setup>
import { ref } from "vue";

const msg = ref('hello world')
const changeMsg = () => {
  msg.value = 'hello juejin'
}
</script>
```

**总结**：

选项式Api是将data和methods包括后面的watch，computed等分开管理，而组合式Api则是将相关逻辑放到了一起（类似于原生js开发）。

setup语法糖则可以让变量方法不用再写return，后面的组件甚至是自定义指令也可以在我们的template中自动获得。

## Vue2和Vue3生命周期函数的区别

```js
Vue 3 的生命周期钩子函数与 Vue 2 的大部分是相似的，并且大部分命名保持一致。Vue 3 引入了 beforeUnmount 和 unmounted 钩子函数来替代 Vue 2 中的 beforeDestroy 和 destroyed。 就是将vue2的销毁前后 改为了卸载前后

在 Vue 3 中，使用了新的 setup() 函数和 Composition API 来替代 Vue 2 中的 beforeCreate 和 created 钩子函数。
```

## 虚拟DOM优缺点

```js
优点

保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；

无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；

跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。

缺点

无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。

首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。
```

## Key的作用

```js
vue中的key有什么作用? (key的内部原理)reacts
1。虚拟DOM中key的作用:
key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据[新数据]生成[新的虚拟DOM]随后Vue进行[新虚拟DOM]与[旧虚拟DOM]的差异比较，比较规则如下:
2.对比规则:
(1).旧虚拟DOM中找到了与新虚拟DOM相同的key:1.若虚拟DOM中内容没变，直接使用之前的真实DOM!2.若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉员面中之前的真实DOM。
(2).旧虚拟DOM中未找到与新虑拟DOM相同的key创建新的真实DOM，随后渲染到到页面。
3，用index作为key可能会引发的问题:1，若对数据进行:逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实DOM更新 ==> 界面效果没问题，但效率低.
2，如果结构中还包含输入类的DOM:会产生借误DOM更新 ==> 界面有问题
```

## ref 和 reactive

我们都知道在选项式api中，data函数中的数据都具有响应式，页面会随着data中的数据变化而变化，而组合式api中不存在data函数该如何呢？所以为了解决这个问题Vue3引入了ref和reactive函数来将使得变量成为响应式的数据

- 组合式Api

```js
js复制代码<script>
import { ref,reactive,defineComponent } from "vue";
export default defineComponent({
setup() {
let msg = ref('hello world')
let obj = reactive({
    name:'juejin',
    age:3
})
const changeData = () => {
    msg.value = 'hello juejin'
    obj.name = 'hello world'
}
return {
    msg,
    obj,
    changeData
};
},
});
</script>
```

- setup语法糖

```js
js复制代码<script setup>
import { ref,reactive } from "vue";
let msg = ref('hello world')
let obj = reactive({
    name:'juejin',
    age:3
})
const changeData = () => {
  msg.value = 'hello juejin'
  obj.name = 'hello world'
}
</script>
```

**总结**：

使用ref的时候在js中取值的时候需要加上.value。

reactive更推荐去定义复杂的数据类型 ref 更推荐定义基本类型

## 生命周期

下表包含：Vue2和Vue3生命周期的差异

| Vue2(选项式API) | Vue3(setup)     | 描述               |
| --------------- | --------------- | ------------------ |
| beforeCreate    | -               | 实例创建前         |
| created         | -               | 实例创建后         |
| beforeMount     | onBeforeMount   | DOM挂载前调用      |
| mounted         | onMounted       | DOM挂载完成调用    |
| beforeUpdate    | onBeforeUpdate  | 数据更新之前被调用 |
| updated         | onUpdated       | 数据更新之后被调用 |
| beforeDestroy   | onBeforeUnmount | 组件销毁前调用     |
| destroyed       | onUnmounted     | 组件销毁完成调用   |

举个常用的onMounted的例子

- 选项式Api

```js
js复制代码<script>
export default  {
  mounted(){
    console.log('挂载完成')
  }
}
</script>
```

- 组合式Api

```js
js复制代码<script>
import { onMounted,defineComponent } from "vue";
export default defineComponent({
setup() {
onMounted(()=>{
  console.log('挂载完成')
})
return {
onMounted
};
},
});
</script>
```

- setup语法糖

```js
js复制代码<script setup>
import { onMounted } from "vue";
onMounted(()=>{
  console.log('挂载完成')
})
</script>
```

从上面可以看出Vue3中的组合式API采用hook函数引入生命周期；其实不止生命周期采用hook函数引入，像watch、computed、路由守卫等都是采用hook函数实现

**总结**

Vue3中的生命周期相对于Vue2做了一些调整，命名上发生了一些变化并且移除了beforeCreate和created，因为setup是围绕beforeCreate和created生命周期钩子运行的，所以不再需要它们。

生命周期采用hook函数引入

## watch和computed

- 选项式API

```js
js复制代码<template>
  <div>{{ addSum }}</div>
</template>
<script>
export default {
  data() {
    return {
      a: 1,
      b: 2
    }
  },
  computed: {
    addSum() {
      return this.a + this.b
    }
  },
  watch:{
    a(newValue, oldValue){
      console.log(`a从${oldValue}变成了${newValue}`)
    }
  }
}
</script>
```

- 组合式Api

```js
js复制代码<template>
  <div>{{addSum}}</div>
</template>
<script>
import { computed, ref, watch, defineComponent } from "vue";
export default defineComponent({
  setup() {
    const a = ref(1)
    const b = ref(2)
    let addSum = computed(() => {
      return a.value+b.value
    })
    watch(a, (newValue, oldValue) => {
     console.log(`a从${oldValue}变成了${newValue}`)
    })
    return {
      addSum
    };
  },
});
</script>
```

- setup语法糖

```js
js复制代码<template>
  <div>{{ addSum }}</div>
</template>
<script setup>
import { computed, ref, watch } from "vue";
const a = ref(1)
const b = ref(2)
let addSum = computed(() => {
  return a.value + b.value
})
watch(a, (newValue, oldValue) => {
  console.log(`a从${oldValue}变成了${newValue}`)
})
</script>
```

Vue3中除了watch，还引入了副作用监听函数watchEffect，用过之后我发现它和React中的useEffect很像，只不过watchEffect不需要传入依赖项。

那么什么是watchEffect呢？

watchEffect它会立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。

比如这段代码

```js
js复制代码<template>
  <div>{{ watchTarget }}</div>
</template>
<script setup>
import { watchEffect,ref } from "vue";
const watchTarget = ref(0)
watchEffect(()=>{
  console.log(watchTarget.value)
})
setInterval(()=>{
  watchTarget.value++
},1000)
</script>
```

首先刚进入页面就会执行watchEffect中的函数打印出:0,随着定时器的运行，watchEffect监听到依赖数据的变化回调函数每隔一秒就会执行一次

**总结**

computed和watch所依赖的数据必须是响应式的。Vue3引入了watchEffect,watchEffect 相当于将 watch 的依赖源和回调函数合并，当任何你有用到的响应式依赖更新时，该回调函数便会重新执行。不同于 watch的是watchEffect的回调函数会被立即执行，即（{ immediate: true }）

## 组件通信

Vue中组件通信方式有很多，其中选项式API和组合式API实现起来会有很多差异；这里将介绍如下组件通信方式：

| 方式             | Vue2       | Vue3                 |
| ---------------- | ---------- | -------------------- |
| 父传子           | props      | props                |
| 子传父           | $emit      | emits                |
| 父传子           | $attrs     | attrs                |
| 子传父           | $listeners | 无(合并到 attrs方式) |
| 父传子           | provide    | provide              |
| 子传父           | inject     | inject               |
| 子组件访问父组件 | $parent    | 无                   |
| 父组件访问子组件 | $children  | 无                   |
| 父组件访问子组件 | $ref       | expose&ref           |
| 兄弟传值         | EventBus   | mitt                 |

### props

props是组件通信中最常用的通信方式之一。父组件通过v-bind传入，子组件通过props接收，下面是它的三种实现方式

- 选项式API

```js
js复制代码//父组件

<template>
  <div>
    <Child :msg="parentMsg" />
  </div>
</template>
<script>
import Child from './Child'
export default {
  components:{
    Child
  },
  data() {
    return {
      parentMsg: '父组件信息'
    }
  }
}
</script>


//子组件

<template>
  <div>
    {{msg}}
  </div>
</template>
<script>
export default {
  props:['msg']
}
</script>
```

- 组合式Api

```js
js复制代码//父组件

<template>
  <div>
    <Child :msg="parentMsg" />
  </div>
</template>
<script>
import { ref,defineComponent } from 'vue'
import Child from './Child.vue'
export default defineComponent({
  components:{
    Child
  },
  setup() {
    const parentMsg = ref('父组件信息')
    return {
      parentMsg
    };
  },
});
</script>

//子组件

<template>
    <div>
        {{ parentMsg }}
    </div>
</template>
<script>
import { defineComponent,toRef } from "vue";
export default defineComponent({
    props: ["msg"],// 如果这行不写，下面就接收不到
    setup(props) {
        console.log(props.msg) //父组件信息
        let parentMsg = toRef(props, 'msg')
        return {
            parentMsg
        };
    },
});
</script>
```

- setup语法糖

```js
js复制代码
//父组件

<template>
  <div>
    <Child :msg="parentMsg" />
  </div>
</template>
<script setup>
import { ref } from 'vue'
import Child from './Child.vue'
const parentMsg = ref('父组件信息')
</script>

//子组件

<template>
    <div>
        {{ parentMsg }}
    </div>
</template>
<script setup>
import { toRef, defineProps } from "vue";
const props = defineProps(["msg"]);
console.log(props.msg) //父组件信息
let parentMsg = toRef(props, 'msg')
</script>
```

**注意**

props中数据流是单项的，即子组件不可改变父组件传来的值

在组合式API中，如果想在子组件中用其它变量接收props的值时需要使用toRef将props中的属性转为响应式。

### emit

子组件可以通过emit发布一个事件并传递一些参数，父组件通过v-on进行这个事件的监听

- 选项式API

```js
js复制代码
//父组件

<template>
  <div>
    <Child @sendMsg="getFromChild" />
  </div>
</template>
<script>
import Child from './Child'
export default {
  components:{
    Child
  },
  methods: {
    getFromChild(val) {
      console.log(val) //我是子组件数据
    }
  }
}
</script>

// 子组件

<template>
  <div>
    <button @click="sendFun">send</button>
  </div>
</template>
<script>
export default {
  methods:{
    sendFun(){
      this.$emit('sendMsg','我是子组件数据')
    }
  }
}
</script>
```

- 组合式Api

```js
js复制代码
//父组件

<template>
  <div>
    <Child @sendMsg="getFromChild" />
  </div>
</template>
<script>
import Child from './Child'
import { defineComponent } from "vue";
export default defineComponent({
  components: {
    Child
  },
  setup() {
    const getFromChild = (val) => {
      console.log(val) //我是子组件数据
    }
    return {
      getFromChild
    };
  },
});
</script>

//子组件

<template>
    <div>
        <button @click="sendFun">send</button>
    </div>
</template>

<script>
import { defineComponent } from "vue";
export default defineComponent({
    emits: ['sendMsg'],
    setup(props, ctx) {
        const sendFun = () => {
            ctx.emit('sendMsg', '我是子组件数据')
        }
        return {
            sendFun
        };
    },
});
</script>
```

- setup语法糖

```js
js复制代码
//父组件

<template>
  <div>
    <Child @sendMsg="getFromChild" />
  </div>
</template>
<script setup>
import Child from './Child'
const getFromChild = (val) => {
      console.log(val) //我是子组件数据
    }
</script>

//子组件

<template>
    <div>
        <button @click="sendFun">send</button>
    </div>
</template>
<script setup>
import { defineEmits } from "vue";
const emits = defineEmits(['sendMsg'])
const sendFun = () => {
    emits('sendMsg', '我是子组件数据')
}
</script>
```

### attrs和listeners

子组件使用$attrs可以获得父组件除了props传递的属性和特性绑定属性 (class和 style)之外的所有属性。

子组件使用$listeners可以获得父组件(不含.native修饰器的)所有v-on事件监听器，在Vue3中已经不再使用；但是Vue3中的attrs不仅可以获得父组件传来的属性也可以获得父组件v-on事件监听器

- 选项式API

```js
js复制代码
//父组件

<template>
  <div>
    <Child @parentFun="parentFun" :msg1="msg1" :msg2="msg2"  />
  </div>
</template>
<script>
import Child from './Child'
export default {
  components:{
    Child
  },
  data(){
    return {
      msg1:'子组件msg1',
      msg2:'子组件msg2'
    }
  },
  methods: {
    parentFun(val) {
      console.log(`父组件方法被调用,获得子组件传值：${val}`)
    }
  }
}
</script>

//子组件

<template>
  <div>
    <button @click="getParentFun">调用父组件方法</button>
  </div>
</template>
<script>
export default {
  methods:{
    getParentFun(){
      this.$listeners.parentFun('我是子组件数据')
    }
  },
  created(){
    //获取父组件中所有绑定属性
    console.log(this.$attrs)  //{"msg1": "子组件msg1","msg2": "子组件msg2"}
    //获取父组件中所有绑定方法    
    console.log(this.$listeners) //{parentFun:f}
  }
}
</script>
```

- 组合式API

```js
js复制代码
//父组件

<template>
  <div>
    <Child @parentFun="parentFun" :msg1="msg1" :msg2="msg2" />
  </div>
</template>
<script>
import Child from './Child'
import { defineComponent,ref } from "vue";
export default defineComponent({
  components: {
    Child
  },
  setup() {
    const msg1 = ref('子组件msg1')
    const msg2 = ref('子组件msg2')
    const parentFun = (val) => {
      console.log(`父组件方法被调用,获得子组件传值：${val}`)
    }
    return {
      parentFun,
      msg1,
      msg2
    };
  },
});
</script>

//子组件

<template>
    <div>
        <button @click="getParentFun">调用父组件方法</button>
    </div>
</template>
<script>
import { defineComponent } from "vue";
export default defineComponent({
    emits: ['sendMsg'],
    setup(props, ctx) {
        //获取父组件方法和事件
        console.log(ctx.attrs) //Proxy {"msg1": "子组件msg1","msg2": "子组件msg2"}
        const getParentFun = () => {
            //调用父组件方法
            ctx.attrs.onParentFun('我是子组件数据')
        }
        return {
            getParentFun
        };
    },
});
</script>
```

- setup语法糖

```js
js复制代码
//父组件

<template>
  <div>
    <Child @parentFun="parentFun" :msg1="msg1" :msg2="msg2" />
  </div>
</template>
<script setup>
import Child from './Child'
import { ref } from "vue";
const msg1 = ref('子组件msg1')
const msg2 = ref('子组件msg2')
const parentFun = (val) => {
  console.log(`父组件方法被调用,获得子组件传值：${val}`)
}
</script>

//子组件

<template>
    <div>
        <button @click="getParentFun">调用父组件方法</button>
    </div>
</template>
<script setup>
import { useAttrs } from "vue";

const attrs = useAttrs()
//获取父组件方法和事件
console.log(attrs) //Proxy {"msg1": "子组件msg1","msg2": "子组件msg2"}
const getParentFun = () => {
    //调用父组件方法
    attrs.onParentFun('我是子组件数据')
}
</script>
```

**注意**

Vue3中使用attrs调用父组件方法时，方法前需要加上on；如parentFun->onParentFun

### provide/inject

provide：是一个对象，或者是一个返回对象的函数。里面包含要给子孙后代属性

inject：一个字符串数组，或者是一个对象。获取父组件或更高层次的组件provide的值，既在任何后代组件都可以通过inject获得

- 选项式API

```js
js复制代码
//父组件
<script>
import Child from './Child'
export default {
  components: {
    Child
  },
  data() {
    return {
      msg1: '子组件msg1',
      msg2: '子组件msg2'
    }
  },
  provide() {
    return {
      msg1: this.msg1,
      msg2: this.msg2
    }
  }
}
</script>

//子组件

<script>
export default {
  inject:['msg1','msg2'],
  created(){
    //获取高层级提供的属性
    console.log(this.msg1) //子组件msg1
    console.log(this.msg2) //子组件msg2
  }
}
</script>
```

- 组合式API

```js
js复制代码
//父组件

<script>
import Child from './Child'
import { ref, defineComponent,provide } from "vue";
export default defineComponent({
  components:{
    Child
  },
  setup() {
    const msg1 = ref('子组件msg1')
    const msg2 = ref('子组件msg2')
    provide("msg1", msg1)
    provide("msg2", msg2)
    return {
      
    }
  },
});
</script>

//子组件

<template>
    <div>
        <button @click="getParentFun">调用父组件方法</button>
    </div>
</template>
<script>
import { inject, defineComponent } from "vue";
export default defineComponent({
    setup() {
        console.log(inject('msg1').value) //子组件msg1
        console.log(inject('msg2').value) //子组件msg2
    },
});
</script>
```

- setup语法糖

```js
js复制代码
//父组件
<script setup>
import Child from './Child'
import { ref,provide } from "vue";
const msg1 = ref('子组件msg1')
const msg2 = ref('子组件msg2')
provide("msg1",msg1)
provide("msg2",msg2)
</script>

//子组件

<script setup>
import { inject } from "vue";
console.log(inject('msg1').value) //子组件msg1
console.log(inject('msg2').value) //子组件msg2
</script>
```

**说明**

provide/inject一般在深层组件嵌套中使用合适。一般在组件开发中用的居多。

### parent/children

$parent: 子组件获取父组件Vue实例，可以获取父组件的属性方法等

$children: 父组件获取子组件Vue实例，是一个数组，是直接儿子的集合，但并不保证子组件的顺序

- Vue2

```js
js复制代码import Child from './Child'
export default {
  components: {
    Child
  },
  created(){
    console.log(this.$children) //[Child实例]
    console.log(this.$parent)//父组件实例
  }
}
```

**注意** 父组件获取到的`$children`并不是响应式的

### expose&ref

$refs可以直接获取元素属性，同时也可以直接获取子组件实例

- 选项式API

```js
js复制代码
//父组件

<template>
  <div>
    <Child ref="child" />
  </div>
</template>
<script>
import Child from './Child'
export default {
  components: {
    Child
  },
  mounted(){
    //获取子组件属性
    console.log(this.$refs.child.msg) //子组件元素

    //调用子组件方法
    this.$refs.child.childFun('父组件信息')
  }
}
</script>

//子组件 

<template>
  <div>
    <div></div>
  </div>
</template>
<script>
export default {
  data(){
    return {
      msg:'子组件元素'
    }
  },
  methods:{
    childFun(val){
      console.log(`子组件方法被调用,值${val}`)
    }
  }
}
</script>
```

- 组合式API

```js
js复制代码
//父组件

<template>
  <div>
    <Child ref="child" />
  </div>
</template>
<script>
import Child from './Child'
import { ref, defineComponent, onMounted } from "vue";
export default defineComponent({
  components: {
    Child
  },

  setup() {
    const child = ref() //注意命名需要和template中ref对应
    onMounted(() => {
      //获取子组件属性
      console.log(child.value.msg) //子组件元素

      //调用子组件方法
      child.value.childFun('父组件信息')
    })
    return {
      child //必须return出去 否则获取不到实例
    }
  },
});
</script>

//子组件

<template>
    <div>
    </div>
</template>
<script>
import { defineComponent, ref } from "vue";
export default defineComponent({
    setup() {
        const msg = ref('子组件元素')
        const childFun = (val) => {
            console.log(`子组件方法被调用,值${val}`)
        }
        return {
            msg,
            childFun
        }
    },
});
</script>
```

- setup语法糖

```js
js复制代码
//父组件

<template>
  <div>
    <Child ref="child" />
  </div>
</template>
<script setup>
import Child from './Child'
import { ref, onMounted } from "vue";
const child = ref() //注意命名需要和template中ref对应
onMounted(() => {
  //获取子组件属性
  console.log(child.value.msg) //子组件元素

  //调用子组件方法
  child.value.childFun('父组件信息')
})
</script>

//子组件

<template>
    <div>
    </div>
</template>
<script setup>
import { ref,defineExpose } from "vue";
const msg = ref('子组件元素')
const childFun = (val) => {
    console.log(`子组件方法被调用,值${val}`)
}
//必须暴露出去父组件才会获取到
defineExpose({
    childFun,
    msg
})
</script>
```

**注意**

通过ref获取子组件实例必须在页面挂载完成后才能获取。

在使用setup语法糖时候，子组件必须元素或方法暴露出去父组件才能获取到

### EventBus/mitt

兄弟组件通信可以通过一个事件中心EventBus实现，既新建一个Vue实例来进行事件的监听，触发和销毁。

在Vue3中没有了EventBus兄弟组件通信，但是现在有了一个替代的方案`mitt.js`，原理还是 EventBus

- 选项式API

```js
js复制代码//组件1
<template>
  <div>
    <button @click="sendMsg">传值</button>
  </div>
</template>
<script>
import Bus from './bus.js'
export default {
  data(){
    return {
      msg:'子组件元素'
    }
  },
  methods:{
    sendMsg(){
      Bus.$emit('sendMsg','兄弟的值')
    }
  }
}
</script>

//组件2

<template>
  <div>
    组件2
  </div>
</template>
<script>
import Bus from './bus.js'
export default {
  created(){
   Bus.$on('sendMsg',(val)=>{
    console.log(val);//兄弟的值
   })
  }
}
</script>

//bus.js

import Vue from "vue"
export default new Vue()
```

- 组合式API

首先安装mitt

```js
js
复制代码npm i mitt -S
```

然后像Vue2中`bus.js`一样新建`mitt.js`文件

mitt.js

```js
js复制代码import mitt from 'mitt'
const Mitt = mitt()
export default Mitt
javascript复制代码//组件1
<template>
     <button @click="sendMsg">传值</button>
</template>
<script>
import { defineComponent } from "vue";
import Mitt from './mitt.js'
export default defineComponent({
    setup() {
        const sendMsg = () => {
            Mitt.emit('sendMsg','兄弟的值')
        }
        return {
           sendMsg
        }
    },
});
</script>

//组件2
<template>
  <div>
    组件2
  </div>
</template>
<script>
import { defineComponent, onUnmounted } from "vue";
import Mitt from './mitt.js'
export default defineComponent({
  setup() {
    const getMsg = (val) => {
      console.log(val);//兄弟的值
    }
    Mitt.on('sendMsg', getMsg)
    onUnmounted(() => {
      //组件销毁 移除监听
      Mitt.off('sendMsg', getMsg)
    })

  },
});
</script>
```

- setup语法糖

```js
js复制代码
//组件1

<template>
    <button @click="sendMsg">传值</button>
</template>
<script setup>
import Mitt from './mitt.js'
const sendMsg = () => {
    Mitt.emit('sendMsg', '兄弟的值')
}
</script>

//组件2

<template>
  <div>
    组件2
  </div>
</template>
<script setup>
import { onUnmounted } from "vue";
import Mitt from './mitt.js'
const getMsg = (val) => {
  console.log(val);//兄弟的值
}
Mitt.on('sendMsg', getMsg)
onUnmounted(() => {
  //组件销毁 移除监听
  Mitt.off('sendMsg', getMsg)
})
</script>
```

## v-model和sync

v-model大家都很熟悉，就是双向绑定的语法糖。这里不讨论它在input标签的使用；只是看一下它和sync在组件中的使用

我们都知道Vue中的props是单向向下绑定的；每次父组件更新时，子组件中的所有props都会刷新为最新的值；但是如果在子组件中修改 props ，Vue会向你发出一个警告（无法在子组件修改父组件传递的值)；可能是为了防止子组件无意间修改了父组件的状态，来避免应用的数据流变得混乱难以理解。

但是可以在父组件使用子组件的标签上声明一个监听事件，子组件想要修改props的值时使用$emit触发事件并传入新的值，让父组件进行修改。

为了方便vue就使用了`v-model`和`sync`语法糖。

- 选项式API

```js
js复制代码
//父组件

<template>
  <div>
   <!-- 
      完整写法
      <Child @update:changePval="msg=$event" /> 
      -->
    <Child :changePval.sync="msg" />
    {{msg}}
  </div>
</template>
<script>
import Child from './Child'
export default {
  components: {
    Child
  },
  data(){
    return {
      msg:'父组件值'
    }
  }
  
}
</script>

//子组件

<template>
  <div>
    <button @click="changePval">改变父组件值</button>
  </div>
</template>
<script>
export default {
  data(){
    return {
      msg:'子组件元素'
    }
  },
  methods:{
    changePval(){
       //点击则会修改父组件msg的值
      this.$emit('update:changePval','改变后的值')
    }
  }
}
</script>
```

- setup语法糖

因为使用的都是前面提过的知识，所以这里就不展示组合式API的写法了

```js
js复制代码//父组件

<template>
  <div>
    <!-- 
      完整写法
      <Child @update:changePval="msg=$event" /> 
      -->
    <Child v-model:changePval="msg" />
    {{msg}}
  </div>
</template>
<script setup>
import Child from './Child'
import { ref } from 'vue'
const msg = ref('父组件值')
</script>

//子组件

<template>
    <button @click="changePval">改变父组件值</button>
</template>
<script setup>
import { defineEmits } from 'vue';
const emits = defineEmits(['changePval'])
const changePval = () => {
    //点击则会修改父组件msg的值
    emits('update:changePval','改变后的值')
}
</script>
```

**总结**

vue3中移除了sync的写法，取而代之的式v-model:event的形式

其`v-model:changePval="msg"`或者`:changePval.sync="msg"`的完整写法为 `@update:changePval="msg=$event"`。

所以子组件需要发送`update:changePval`事件进行修改父组件的值

## 路由

vue3和vue2路由常用功能只是写法上有些区别

- 选项式API

```js
js复制代码<template>
  <div>
     <button @click="toPage">路由跳转</button>
  </div>
</template>
<script>
export default {
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    next()
  },
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    next()
  },
  beforeRouteLeave ((to, from, next)=>{//离开当前的组件，触发
    next()       
  }),
  beforeRouteLeave((to, from, next)=>{//离开当前的组件，触发
    next()      
  }),
  methods:{
    toPage(){
      //路由跳转
      this.$router.push(xxx)
    }
  },
  created(){
    //获取params
    this.$route.params
    //获取query
    this.$route.query
  }
}
</script>
```

- 组合式API

```js
js复制代码<template>
  <div>
    <button @click="toPage">路由跳转</button>
  </div>
</template>
<script>
import { defineComponent } from 'vue'
import { useRoute, useRouter } from 'vue-router'
export default defineComponent({
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    next()
  },
  beforeRouteLeave ((to, from, next)=>{//离开当前的组件，触发
    next()       
  }),
  beforeRouteLeave((to, from, next)=>{//离开当前的组件，触发
    next()      
  }),
  setup() {
    const router = useRouter()
    const route = useRoute()
    const toPage = () => {
      router.push(xxx)
    }

    //获取params 注意是route
    route.params
    //获取query
    route.query
    return {
      toPage
    }
  },
});
</script>
```

- setup语法糖

我之所以用`beforeRouteEnter`作为路由守卫的示例是因为它在`setup`语法糖中是无法使用的；大家都知道`setup`中组件实例已经创建，是能够获取到组件实例的。而`beforeRouteEnter`是再进入路由前触发的，此时组件还未创建，所以是无法用在`setup`中的；如果想在setup语法糖中使用则需要再写一个`script` 如下：

```js
js复制代码<template>
  <div>
    <button @click="toPage">路由跳转</button>
  </div>
</template>
<script>
export default {
  beforeRouteEnter(to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    next()
  },
};
</script>

<script setup>
import { useRoute, useRouter，onBeforeRouteLeave, onBeforeRouteUpdate } from 'vue-router'
const router = useRouter()
const route = useRoute()
const toPage = () => {
  router.push(xxx)
}
//获取params 注意是route
route.params
//获取query
route.query

//路由守卫
onBeforeRouteUpdate((to, from, next)=>{//当前组件路由改变后，进行触发
    next() 
})
onBeforeRouteLeave((to, from, next)=>{//离开当前的组件，触发
    next() 
})

</script>
```

