## JS 进阶知识点

## 执行上下文

JavaScript代码中执行代码的环境。它包括全局执行上下文和函数执行上下文。

全局执行上下文和函数执行上下文和块级上下文

全局执行上下文指的是在浏览器或Node.js环境中，JavaScript代码的全局执行环境。在全局执行环境下，任何函数都可以被调用，并且可以访问全局变量和对象。

函数执行上下文指的是在函数内部定义的执行环境。在函数执行环境下，只有函数内部的变量和对象是可访问的，外部的变量和对象是不可访问的。

JavaScript中的执行上下文是在代码执行时确定的。例如，在一个函数内部定义的变量只能在该函数内部访问，而在函数外部定义的变量可以在该函数内部访问。

块级上下文是指在一个函数内部声明的变量和函数，它们的作用域仅限于该函数内部。块级上下文可以通过使用大括号({})来定义。

## 作用域链

◼ 当进入到一个执行上下文时，执行上下文也会关联一个作用域链（Scope
Chain）

 作用域链是一个对象列表，用于变量标识符的求值；


当进入一个执行上下文时，这个作用域链被创建，并且根据代码类型，添加一系列的对象；

作用域链 本质是变量查找机制

在函数被执行时 会优先查找当前函数作用域中查找变量

如果当前作用域查不到则会依次逐级查找父级作用域直到全局作用域

总结：

嵌套关系的作用域串联起来形成了作用域链

相同作用域链中按着从小到大的规则查找变量

子作用域能够访问父作用域 父作用域无法访问子级作用域

## 构造函数

在JavaScript中，构造函数是一种特殊的函数，就是用来创建新对象的函数，用于创建和初始化对象。构造函数使用关键字new来调用，并且必须有一个参数，即要创建的对象的原型(prototype)。

构造函数也是函数 任何函数只要使用new关键字来调用就是构造函数
而不是用new关键字调用的就是普通函数

同一个构造函数创建出来的两个实例 共享同一个原型对象

instanceof检查实例的原型链中是否包含指定构造函数原型

特点：

1\. 没有显示的创建对象

2.属性和方法直接赋给了this

3.没return

要创建新对象的执行顺序

1.创建新的对象

2.这个新对象内部的_proto_被赋值给这个构造函数的prototype属性

3.改变this指向 让this指向新对象

4.执行构造函数里面的代码 也就是给新对象添加属性和方法

5.如果构造函数返回非空的对象 则返回该对象 如果不为空
则返回刚创建的新对象

！！注意 创建出来的新对象身上都有一个constructor属性指向构造函数

所有的自定义对象都继承自Object

## 原型和原型链

当通过一个构造函数 来new实例化一个新对象
这个新对象身上就会有一个_proto_属性 就是这个新对象的隐式原型
这个新对象的隐式原型就等于构造函数身上的显示原型 就是 新对象.\_proto\_
=== 构造函数.prototype 然后 函数也是对象
所以构造函数身上不仅有显示原型也有隐式原型
这个构造函数的原型上的隐式原型指向Object.prototype
这个构造函数身上也会有个隐式原型 这个隐式原型指向function.prototype 最后
也是个对象 他也有隐式原型 最终也指向Object.prototype

## 作用域

作用域（scope）规定了变量能够被访问的"范围" 离开这个"范围"变量便不可访问

局部作用域

### 1\. 函数作用域

在函数内部声明的变量只能在函数内部被访问，外部无法访问

注意：

函数的参数也是函数内部的局部变量

不同函数内部声明的变量无法相互访问

函数执行完毕后 函数内部的变量实际被清空了

### 2.块作用域

在 javascript 中使用 { } 包裹的代码称为代码块 代码块内部声明的变量外部将
【有可能】无法被访问

![图片](media/image1.png){width="5.5in" height="2.2270374015748033in"}

注意：

let 声明的变量会产生块作用域 var 不会产生块作用域

const 声明的变量也会产生块作用域

不同代码之间的变量无法相互访问

推荐使用 let 或者 const

![图片](media/image2.png){width="5.5in" height="1.9886209536307962in"}

### 全局作用域

\<script\>标签和.js 的最外层 就是所谓得全局作用域
在此声明的变量在函数内部也可以被访问

注意：

为 window 对象动态添加的属性默认也是全局的 不推荐！

函数中未使用任何关键字声明的变量为全局变量 不推荐！

尽可能少的声明全局变量 防止全局变量被污染

![图片](media/image3.png){width="5.5in" height="2.4924464129483814in"}

## JS 垃圾回收机制

垃圾回收机制简称 GC

Js
中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收

内存的生命周期

JS 环境中分配的内存，一般有如下生命周期：

1.内存分配 ：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存

2.内存使用：即读写内存，也就是使用变量，函数等

3.内存回收：使用完毕，由垃圾回收器自动回收不再使用的内存

说明：

全局变量一般不会回收（除非关闭页面才会回收）

一般情况下局部变量的值 不用了 会被自动回收掉

内存泄漏：程序中分配的内存由于某种原因程序未释放或无法释放叫做内存泄漏

JS 垃圾回收机制-算法说明

堆栈空间的分配区别：

1.栈（操作系统）：由操作系统自动分配释放函数的参数值、局部变量等
基本数据类型放到栈里面

2.堆（操作系统）:一般由程序员分配释放 若程序员不释放
由垃圾回收机制回收。复杂数据类型放到堆里面

垃圾回收算法：引用计数法 和 标记清除法

### 引用计数法 ：

IE
采用的引用计数法，定义"内存不在使用"，就是看一个对象是否有指向他的引用，没有引用了就回收对象

算法：

1。跟踪记录被引用的次数

2。如果被引用了一次 那么就记录次数 1 多次引用会累加 ++

3。如果减少一个引用就减 1 \--

4。如果引用次数是 0 则释放内存

![图片](media/image4.png){width="5.5in" height="1.8596741032370954in"}

存在一个致命问题：嵌套引用(循环引用)

如果两个对象相互引用 尽管他们不在使用 垃圾回收机制不会进行回收
导致内存泄漏

![图片](media/image5.png){width="5.5in" height="2.376288276465442in"}

### 标记清除法：

标记清除法将"不再使用的对象"定义为"无法达到的对象"

就是从根部（在 JS 中就是全局对象）
出发定时扫描内存中的对象，凡是能够从根部到达的对象，都是还需要使用的

那些无法从根部出发触及到的对象被标记为不在使用 稍后进行回收

![图片](media/image6.png){width="5.5in" height="1.5247517497812773in"}

## 闭包

### 闭包的概念

一个函数对周围状态的引用捆绑在一起 内层函数访问到其外层函数的作用域

简单理解： 闭包=内层函数+外层函数的变量

### 作用：

封装数据 提供操作
外部也可以访问函数内部的变量![图片](media/image7.png){width="5.5in"
height="2.0796391076115484in"}

闭包的基本格式

![图片](media/image8.png){width="5.118055555555555in"
height="3.3406944444444444in"}

![图片](media/image9.png){width="5.5in" height="2.101068460192476in"}

闭包的应用：实现数据私有

比如 我们要统计函数调用次数 函数调用一次 就++

![图片](media/image10.png){width="5.5in" height="2.30718394575678in"}

闭包总结

![图片](media/image11.png){width="5.5in" height="2.2689293525809275in"}

## 变量提升

变量提升是 javascript 中比较"奇怪"得现象
他允许在变量声明之前即被访问（仅存在于 Var 声明的变量）

当代码在执行之前 内部会把所有 var 声明的变量 提升到当前作用域的最前面

只提升变量声明 不提升变量赋值

![图片](media/image12.png){width="5.5in" height="1.7497758092738407in"}

函数进阶

函数提升

是指函数在声明之前就可以被调用

![图片](media/image13.png){width="5.5in" height="2.2482852143482064in"}

函数提升总结

![图片](media/image14.png){width="5.5in" height="2.2213396762904636in"}

## 函数参数

函数的动态参数

arguments 是函数内部内置的为数组变量，它包含了调用函数时传入的所有实参

arguments\[索引号\] 就可以拿到对应索引的值

动态参数总结

剩余参数

剩余参数允许 我们将一个不定数量的参数表示为一个数组

## 展开运算符

展开运算符(\...)

运用场景：求数组最大值（最小值）、合并数组等

const arr1 = \[1,2,3\]

\...arr === 1,2,3

console.log(Math.max(\...arr1)) 求数组最大值

console.log(Math.min(\...arr1)) 求数组最小值

合并数组

const arr2 = \[3,4,5\]

const arr = \[\...arr1,\...arr2\]

consolr.log(arr)

## 箭头函数

引入箭头函数的目的是更简洁的函数写法并且不绑定this，箭头函数的语法比函数表达式更简洁

使用场景

箭头函数更适用于那些本来就需要匿名函数的地方

箭头函数基本语法

箭头函数参数

1。普通函数里面有arguments动态参数

2.  箭头函数没有arguments 动态参数 ,但是有剩余参数 ..args

![图片](media/image23.png){width="5.4158333333333335in"
height="3.796666666666667in"}

this

this的相关概念

在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定）。this 不能在执行期间被赋值，并且在每次函数被调用时 this 的值也可能会不同。

面向对象语言中 this 表示当前对象的一个引用。

但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。

-   在方法中，this 表示该方法所属的对象。

```{=html}
<!-- -->
```
-   如果单独使用，this 表示全局对象。

```{=html}
<!-- -->
```
-   在函数中，this 表示全局对象。

```{=html}
<!-- -->
```
-   在函数中，在严格模式下，this 是未定义的(undefined)。

```{=html}
<!-- -->
```
-   在事件中，this 表示接收事件的元素。

```{=html}
<!-- -->
```
-   类似 call() 和 apply() 方法可以将 this 引用到任何对象。

普通函数this

全局上下文

无论是否严格模式下
在全局执行的环境中（在任何函数体外部）this都指向全局对象

全局上下文

无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。

![图片](media/image24.png){width="5.0808333333333335in"
height="2.196111111111111in"}

函数上下文

在函数内部 this的取值取决于函数被调用的方式

因为下面的代码不在严格模式下，且 this 的值不是由该调用设置的，所以 this 的值默认指向全局对象，浏览器中就是 window。

![图片](media/image25.png){width="3.8618055555555557in"
height="1.9169444444444443in"}

然而，在严格模式下，如果进入执行环境时没有设置 this 的值，this 会保持为 undefined，如下：

![图片](media/image26.png){width="3.0708333333333333in"
height="1.3958333333333333in"}

## 箭头函数this

在箭头函数出现之前，每一个新函数根据它被如何调用的来定义这个函数的this值，非常令人讨厌

箭头函数不会创建自己的this 它只会从自己的作用域链的上一层沿用this

DOM事件的回调函数为了简便 还是不太推荐使用箭头函数

![图片](media/image27.png){width="5.5in" height="2.273850612423447in"}

函数声明与表达式

js引擎在任何代码执行之前 会先读取函数声明 并在执行上下文中生成函数定义
而函数表达式必须等到代码执行到它哪一行 才会在执行上下文中生成函数定义

这段代码可以正常运行
因为函数声明会在任何代码执行之前先被读取并添加到执行上下文中
这个过程叫做函数声明提升

在执行代码前
js引擎会先执行一遍扫描，把发现的函数声明提升到源代码树的顶部，因此即使函数定义出现在调用它的代码之后
引擎会把函数声明提升到顶部

![图片](media/image28.png){width="3.452361111111111in"
height="1.1166666666666667in"}

这段代码会报错 因为这个函数定义包含在一个变量初始化语句中
而不是函数声明中 这意味着代码如果没有运行到let 哪一行
那么执行上下文中的就没有函数的定义 所以上面的代码会出错
这不是let所导致的 而是var关键字也是碰到这种问题

![图片](media/image29.png){width="2.93125in" height="1.1725in"}

## 解构赋值

数组解构

是将数组的单元值快速批量赋值给一系列变量的简洁语法

1.基本语法：

赋值运算符 = 左侧的\[\]
用于批量声明，右侧数据的单元值将被赋值给左侧的变量

交换两个变量值

！！js必须要加分号的情况

![图片](media/image32.png){width="5.5in" height="2.0686931321084865in"}

2。变量多，单元值少的情况

![图片](media/image33.png){width="5.5in" height="2.1248009623797026in"}

3。变量少，单元值多的情况

![图片](media/image34.png){width="5.322777777777778in"
height="1.42375in"}

4。剩余参数解决

![图片](media/image35.png){width="5.5in" height="1.318241469816273in"}

5。防止有undefined传递单元值的情况，可以设置默认值

![图片](media/image36.png){width="5.5in" height="1.4259251968503937in"}

6.按需导入 忽略某些返回值：

![图片](media/image37.png){width="5.5in" height="1.7087368766404198in"}

7.支持多维数组解构

![图片](media/image38.png){width="5.5in" height="1.7117716535433072in"}

对象解构

![图片](media/image39.png){width="5.0529166666666665in"
height="1.8331944444444443in"}

![图片](media/image40.png){width="4.997083333333333in"
height="2.7079166666666667in"}

![图片](media/image41.png){width="5.5in" height="1.9488790463692038in"}

for Each遍历数组

for Each遍历 不返回值

![图片](media/image42.png){width="5.5in" height="1.7985772090988625in"}

![图片](media/image43.png){width="5.5in" height="2.368173665791776in"}

构造函数

是一种特殊的函数 主要用来初始化对象
（快速创建多个类似的对象）把公共的属性抽取出来封装到一个函数里

注意 创建构造函数有两个约定：

1。它们的命名为大写字母开头

2。它们只能通过"new"这个关键字来执行（实例化）

![图片](media/image44.png){width="5.5in" height="4.589402887139108in"}

实例化执行过程

![图片](media/image45.png){width="5.5in" height="2.01917760279965in"}

实例成员 和静态成员

实例成员：
通过构造函数创建的对象叫做实例对象，实例对象中的属性和方法称为实例成员(实例属性和实例方法)

![图片](media/image46.png){width="5.5in" height="2.023273184601925in"}

静态成员：在构造函数的属性和方法被称为静态成员(静态属性和静态方法)

![图片](media/image47.png){width="5.462361111111111in" height="2.68in"}

总结

![图片](media/image48.png){width="5.5in" height="3.2856200787401573in"}

基本包装类型

![图片](media/image49.png){width="5.5in" height="3.2590540244969377in"}

内置构造函数

Object

Object是内置的构造函数 用于创建普通对象

推荐使用字面量声明对象 而不是Object构造函数

三个常用的静态方法(静态方法就是只有构造函数Object可以调用的)

Object.keys() 和 Object.values()

![图片](media/image50.png){width="5.5in" height="3.002382983377078in"}

拷贝

![图片](media/image51.png){width="5.5in" height="2.324458661417323in"}

新增属性

![图片](media/image52.png){width="5.5in" height="2.497609361329834in"}

异步函数

同步与异步

同步行为对应内存中顺序执行的处理器指令
每条指令都会按照他们的出现顺序来执行

异步行为类似于系统中断 即当前进程外部的实体可以触发代码执行
异步行为是为了优化因计算量大而时间长的操作 如果在等待其他操作完成的同时
即使运行其他指令 系统也能保持稳定 那么这样做就是务实的

promise/A+规范

promise概念

ES6新增的引用类型 可以通过new操作符来实例化

使用promise的场景

最重要也是最主要的一个场景就是ajax和axios请求，通俗来说，由于网速的不同，可能你得到返回值的时间也是不同的，但是我"下一步要执行的代码依赖于上一次请求返回值，这个时候我们就需要等待，结果出来了之后才知道怎么样继续下去。

promise好处

防止出现回调地狱;

提高代码的可读性;

像同步操作那样去执行异步操作

promise的三种状态

1.pending: 等待中，或者进行中，表示还没有得到结果

2.resolved(Fulfilled):
已经完成，表示得到了我们想要的结果，可以继续往下执行

3.rejected: 也表示得到结果，但是由于结果并非我们所愿，因此拒绝执行

promise构造函数

![图片](media/image53.png){width="5.5in" height="3.192189413823272in"}

promise三个状态

为了更好地控制异步功能操作 会有三个状态

![图片](media/image54.png){width="3.536111111111111in"
height="1.7854735345581803in"}

promise中的三个方法

![图片](media/image55.png){width="3.6105555555555555in"
height="2.0058639545056867in"}

then方法的使用

then方法返回的结果也是个promise对象 对象的状态由回调函数的执行结果来决定

1。如果回调函数中返回的结果是一个非promise类型的属性 状态为成功
返回值为promise对象的成功值

2。如果回调函数中返回的结果是一个promise类型的属性
如果结果中的promise对象的状态为成功
那么返回值的promise对象的状态也是成功的 反之则失败

3。抛出错误 也是个失败的promise的状态 错误值为抛出的值

![图片](media/image56.png){width="4.4759722222222225in"
height="2.962478127734033in"}

then方法的链式调用

![图片](media/image57.png){width="5.5in" height="3.9018864829396325in"}

catch方法的使用

then方法当中可以传入两个参数 当然也可以不传递
也可以值传递成功的回调函数也可以单独的来使用catch来专门指定失败的回调函数

catch方法也有返回值
和then方法的返回值类似catch方法也返回一个Promise实例化对象

情况1:如果失败的回调函数中没有返回值 则得到一个成功的promise实例化对象
结果为underfind情况2:如果失败的回调函数中有返回值
但是这个返回值不是promise实例的情况下

则得到一个成功的promise对象
结果为返回值数据情况3:如果失败的回调函数中有返回值
但是这个返回值是promise实例的情况下

则得到的新的promise对象的状态和结果值完全取决于返回的promise对象的状态以及结果值

![图片](media/image58.png){width="5.5in" height="5.506342957130359in"}

finally方法的使用

![图片](media/image59.png){width="5.5in" height="3.175317147856518in"}

async函数

任何函数都可以被声明为一个async函数因为要实现的就是异步功能(定时器
ajax请求)可能是要将我们实现的功能封装到一个函数当中
，为了更好的表示函数之中是异步

所以在函数的前面加 上async

函数内部可以添加任意的一个语句来执行
但是其真正的目的是为了得到一个promise对象的状态以及结果值

1.如果返回值为promise 类型的数据

return 3121 就是一个成功的promise对象 值为3121

2.如果返回值为一个Promise对象
返回的这个promise实例化对象的状态以及结果将直接影响结果产生的promise实例化对象的状态和值

3.如果抛出异常

throw \"oh No\"a

1.函数的返回值为promise对象

2.promise对象的结果由async函数执行的返回值决定

await函数

1.async 函数 结合await 表达式

> 1.1 async函数当中 不一定完全结合await
>
> 1.2 有await函数的一定是async函数

2.await相当于是then 直接可以拿到实例化promise对象的结果值

3.await一定要写在async函数中 但是async函数之中可以没有await

await得到的结果：

1.如果await右侧为非promise类型的数据 await后面的值是什么
得到的结果就是什么

2.如果await右侧为promise成功类型的数据 则得到的结果就是promise成功后的值

3.如果await右侧为promise失败类型的数据 需要我们try catch去捕获
就可以拿到失败的值

注意：加try catch 好处是 有了try catch后续的代码将继续执行

1.awit右侧的表达式一般为promise对象 但也可以是其他的值

2.如果表达式是promise对象，await返回的是promise成功的值

3.如果表达式是其他值 直接将此值作为await的返回值

注意：

1.awit必须写在async函数中 但async函数中可以没有await

2.如果await的promise失败了 就会抛出异常 需要通过trycatch 捕获处理

await表达式的执行顺序

结论：如果有同步代码和异步代码同时出现 一定先执行同步 在执行异步

![图片](media/image60.png){width="5.5in" height="4.9875207786526685in"}

异常处理

throw抛异常

throw抛出异常信息 程序也会终止执行

throw后面跟的是错误提示信息

Error对象配合throw使用 能够设置更详细的错误信息

    \<script type=\"text/javascript\"\>

        function fn(x, y) {

            if (!x \|\| !y) {

                // throw \'没有参数传递进来\'

//throw一般和 Error一起使用

                throw new Error(\'没有参数传递进来\')

            }

            return x + y

        }

        fn()

    \</script\>

try/catch捕获异常

try 试试 catch 拦住 finally 最后

debugger

防抖和节流

1.防抖（debounce）

防抖和节流都是前端开发中常用的两种性能优化技术

为什么要防抖

有的操作是高频触发的，但是其实触发一次就好了，比如我们短时间内多次缩放页面，那么我们不应该每次缩放都去执行操作，应该只做一次就好。再比如说监听输入框的输入，不应该每次都去触发监听，应该是用户完成一段输入后在进行触发。

防抖就是防止抖动，避免事件的重复触发

总结：等用户高频事件完了，再进行事件操作。单位时间内 频繁触发事件
只执行最后一次

防抖的实现方法

lodash提供的防抖来处理

1.引入lodash库

\<script
src=\"https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.21/lodash.js\"x/script\>

2.用\_.debounce(function，时间)

![图片](media/image61.png){width="5.5in" height="3.471735564304462in"}

手写一个防抖函数来处理

事件触发后开启一个定时器，如果事件在这个定时器限定的时间内再次触发，则清除定时器，在写一个定时器，定时时间到则触发。

![图片](media/image62.png){width="5.5in" height="0.9709634733158355in"}

核心思路

![图片](media/image63.png){width="5.5in" height="1.5269116360454944in"}

![图片](media/image64.png){width="5.5in" height="4.207115048118985in"}

节流（throttle）

节流概念

单位时间内 频繁触发事件 只执行一次

使用场景

高频事件：鼠标移动（mousemove） ，页面尺寸缩放resize 滚动条滚动scroll等

节流的实现方法

lodash提供的节流函数来处理

1.引入lodash

\<script
src=\"https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.21/lodash.js\"x/script\>

2.使用

![图片](media/image65.png){width="5.5in" height="3.694028871391076in"}

手写节流函数来处理

核心思路：

核心思路就是 利用定时器（setTimeout）来实现

1.声明一个定时器变量

2.当鼠标每次滑动都先判断是否有定时器了 如果有定时器则不开启新的定时器

3.如果没有定时器则开启定时器 记得存到变量里面

定时器里面调用执行的函数

定时器里面要把定时器清空

![图片](media/image66.png){width="5.5in" height="4.648320209973753in"}
